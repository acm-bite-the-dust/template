#include<iostream>
#include<cstring>
#include<queue>
#include<algorithm>

using namespace std;

const int maxn = 300;
const int maxs = 2e5;

int ans[maxn];

struct ACMachine {
    struct Tree//字典树
    {
        int fail;//失配指针
        int vis[26];//子节点的位置
        int end;//标记以这个节点结尾的单词编号
    } AC[maxs * 10];//Trie树
    int cnt = 0;//Trie的指针

    inline void init(int x) {
        memset(AC[x].vis, 0, sizeof(AC[x].vis));
        AC[x].fail = 0;
        AC[x].end = 0;
    }

    inline void insert(string s, int id) {
        int l = s.length();
        int now = 0;//字典树的当前指针
        for (int i = 0; i < l; ++i)//构造Trie树
        {
            if (AC[now].vis[s[i] - 'a'] == 0)//Trie树没有这个子节点
            {
                AC[now].vis[s[i] - 'a'] = ++cnt;//构造出来
                init(cnt);
            }
            now = AC[now].vis[s[i] - 'a'];//向下构造
        }
        AC[now].end = id;//标记单词结尾
    }

    void solve()//构造fail指针
    {
        AC[0].fail = 0;//结束标志
        queue<int> Q;//队列
        for (int i = 0; i < 26; ++i)//第二层的fail指针提前处理一下
        {
            if (AC[0].vis[i] != 0) {
                AC[AC[0].vis[i]].fail = 0;//指向根节点
                Q.push(AC[0].vis[i]);//压入队列
            }
        }
        while (!Q.empty())//BFS求fail指针
        {
            int u = Q.front();
            Q.pop();
            for (int i = 0; i < 26; ++i)//枚举所有子节点
            {
                if (AC[u].vis[i] != 0)//存在这个子节点
                {
                    AC[AC[u].vis[i]].fail = AC[AC[u].fail].vis[i];
                    //子节点的fail指针指向当前节点的
                    //fail指针所指向的节点的相同子节点
                    Q.push(AC[u].vis[i]);//压入队列
                } else//不存在这个子节点
                    AC[u].vis[i] = AC[AC[u].fail].vis[i];
                //当前节点的这个子节点指向当
                //前节点fail指针的这个子节点
            }
        }
    }

    int query(string s)//AC自动机匹配
    {
        int l = s.length();
        int now = 0, res = 0;
        for (int i = 0; i < l; ++i) {
            now = AC[now].vis[s[i] - 'a'];//向下一层
            for (int t = now; t; t = AC[t].fail)//循环求解
                ans[AC[t].end]++;
        }
        return res;
    }
} ACM;

string s[maxn];

int main() {
    ios_base::sync_with_stdio(false);
    int n;
    while (true) {
        scanf("%d", &n);
        if (n == 0) break;
        ACM.cnt = 0;
        ACM.init(0);
        for (int i = 1; i <= n; ++i) {
            s[i].resize(maxs);
            scanf("%s", &s[i][0]);
            s[i].resize(strlen(&s[i][0]));
            ans[i] = 0;
            ACM.insert(s[i], i);
        }
        ACM.solve();//求出失配指针
        string str;
        str.resize(1e6);
        scanf("%s", &str[0]);//文本串
        str.resize(strlen(&str[0]));
        ACM.query(str);
        int resm = 0;
        for (int i = 1; i <= n; i++) resm = max(resm, ans[i]);
        printf("%d\n", resm);
        for (int i = 1; i <= n; i++) if (ans[i] == resm) printf("%s\n", s[i].c_str());
    }
    return 0;
}
